// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.CommandLine;
using System.CommandLine.Builder;
using System.CommandLine.Help;
using System.CommandLine.Invocation;
using System.CommandLine.Parsing;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Quantum.Qir.Tools;

namespace Microsoft.Quantum.CommandLineCompiler
{
    class Program
    {
        private static async Task<int> Main(string[] args)
        {
            var buildCommand = CreateBuildCommand();

            var root = new RootCommand() { buildCommand };
            SetSubCommandAsDefault(root, buildCommand);
            root.Description = "Command-line tool for processing QIR DLL files.";
            root.TreatUnmatchedTokensAsErrors = true;

            Console.OutputEncoding = Encoding.UTF8;
            return await new CommandLineBuilder(root)
                .UseDefaults()
                .UseHelpBuilder(context => new QsHelpBuilder(context.Console))
                .Build()
                .InvokeAsync(args);
        }

        /// <summary>
        /// Creates the Build command for the command line compiler, which is used to
        /// compile the executables from a given QIR DLL.
        /// </summary>
        /// <returns>The Build command.</returns>
        private static Command CreateBuildCommand()
        {
            var buildCommand = new Command("build", "(default) Build the executables from a QIR DLL.")
            {
                Handler = CommandHandler.Create((BuildOptions settings) =>
                {
                    var thisModulePath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
                    if (string.IsNullOrWhiteSpace(thisModulePath))
                    {
                        throw new InvalidOperationException("TODO");
                    }

                    var headersPath = new DirectoryInfo(Path.Combine(thisModulePath, "runtimes", "any", "native", "include"));
                    var externalsPath = new DirectoryInfo(Path.Combine(thisModulePath, "Externals", "CLI11"));
                    
                    var osArch = Environment.OSVersion.Platform;
                    var osID = "";
                    switch (osArch)
                    {
                        case PlatformID.Win32NT:
                            osID = "win-x64";
                            break;
                        case PlatformID.Unix:
                            osID = "linux-x64";
                            break;
                        case PlatformID.MacOSX:
                            osID = "osx-x64";
                            break;
                        default:
                            throw new ArgumentException("TODO");
                    }

                    var runTimePath = new DirectoryInfo(Path.Combine(thisModulePath, "runtimes", osID, "native"));
                    var simulatorsPath = new DirectoryInfo(Path.Combine(thisModulePath, "Simulators", osID));

                    return QirTools.BuildFromQSharpDll(settings.QSharpDll, settings.LibraryDirectories.Append(runTimePath).Append(simulatorsPath).ToList() , settings.IncludeDirectories.Append(headersPath).Append(externalsPath).ToList(), settings.ExecutablesDirectory);
                })
            };
            buildCommand.TreatUnmatchedTokensAsErrors = true;

            buildCommand.AddOption(new Option<FileInfo>(
                aliases: new string[] { "--qsharp-dll", "--dll" },
                description: "The path to the .NET DLL file generated by the Q# compiler.")
            {
                Required = true
            });

            buildCommand.AddOption(new Option<DirectoryInfo[]>(
                aliases: new string[] { "--library-directories", "--lib" },
                description: "One or more paths to the directories containing the libraries to be linked.")
            {
                Required = false,
                Argument = new Argument<DirectoryInfo[]>(() => new DirectoryInfo[] { })
                {
                    Arity = ArgumentArity.OneOrMore
                }
            });

            buildCommand.AddOption(new Option<DirectoryInfo[]>(
                aliases: new string[] { "--include-directories", "--include" },
                description: "One or more paths to the directories containing the headers required for compilation.")
            {
                Required = false,
                Argument = new Argument<DirectoryInfo[]>(() => new DirectoryInfo[] { })
                {
                    Arity = ArgumentArity.OneOrMore
                }
            });

            buildCommand.AddOption(new Option<DirectoryInfo>(
                aliases: new string[] { "--executables-directory", "--exe" },
                description: "The path to the output directory where the created executables will be placed.")
            {
                Required = true
            });

            return buildCommand;
        }

        /// <summary>
        /// Copies the handle and options from the given sub command to the given command.
        /// </summary>
        /// <param name="root">The command whose handle and options will be set.</param>
        /// <param name="subCommand">The sub command that will be copied from.</param>
        private static void SetSubCommandAsDefault(Command root, Command subCommand)
        {
            root.Handler = subCommand.Handler;
            foreach (var option in subCommand.Options)
            {
                root.AddOption(option);
            }
        }

        /// <summary>
        /// A modification of the command-line <see cref="HelpBuilder"/> class.
        /// </summary>
        private sealed class QsHelpBuilder : HelpBuilder
        {
            /// <summary>
            /// Creates a new help builder using the given console.
            /// </summary>
            /// <param name="console">The console to use.</param>
            internal QsHelpBuilder(IConsole console) : base(console)
            {
            }

            protected override string ArgumentDescriptor(IArgument argument)
            {
                // Hide long argument descriptors.
                var descriptor = base.ArgumentDescriptor(argument);
                return descriptor.Length > 30 ? argument.Name : descriptor;
            }
        }

        /// <summary>
        /// A class for encapsulating the different options for the build command.
        /// </summary>
        public sealed class BuildOptions
        {
            /// <summary>
            /// The path to the .NET DLL file generated by the Q# compiler.
            /// </summary>
            public FileInfo QSharpDll { get; set; }

            /// <summary>
            /// One or more paths to the directories containing the libraries to be linked.
            /// </summary>
            public DirectoryInfo[] LibraryDirectories { get; set; }

            /// <summary>
            /// One or more paths to the directories containing the headers required for compilation.
            /// </summary>
            public DirectoryInfo[] IncludeDirectories { get; set; }

            /// <summary>
            /// The path to the output directory where the created executables will be placed.
            /// </summary>
            public DirectoryInfo ExecutablesDirectory { get; set; }
        }
    }
}
